# 2_ring_buffer_management
Hello! In my work, I found a interesting algorithm question to consider. At first I thought it is pretty easy, but then I realize this problem is harder than I thought. So I want to make a little thing-y to put together how I think about this algorithm question, and more importantly, in order to check my algorithm, I want to make a visualization. This can be hard to a novice front-end programmer, so let's go slow. 
## Question
There are multiple variants of this problem, let me write down the simple version I have in mind: 
### Version 1.0
We have a ring buffer `A`, and `A.size = sizeA`. And there is a function `write_entity(start_addr, size)` that will write a entity, a chunk of memory on to `A`. We do not allow spliting over a entity, which means, when there is no enough space for the current entity to sit in the end of `A`, we will put the entity in the front. And if there is a potential overlap, we remove the whole old entity. Because I don't want to do too much bookkeeping for this version, let's say that each block written contains a field of size, and a field pointing to the next entity.   
I know I am mixing programming languages... sorry! In fact I am not sure which language to go... I guess I would use a language which can work with front-end, so maybe javascript, typescript or dart? let me do a search! Yeah... this README is not just about the problem, but also the path I took to make the whole thing work~ (well you know i actually have experience just doing data visualization, with d3... but that is when others set up the whole node thing and I just need to write the algorithm, this, is, different!)